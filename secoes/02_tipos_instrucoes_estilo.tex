\begin{frame}{Tipos Básicos do python}
\begin{itemize}
	\item Númericos:
	\begin{itemize}
		\item inteiro (int)
		\item ponto flutuante (float)
		\item booleano (bool) 1 ou 0
		\item complexo (complex)
	\end{itemize}
\end{itemize}
\begin{itemize}
		\item Obs:
		\begin{itemize}
			\item Suportam as operações básicas, mod, etc (+, -, *, /, \%, **, +=, -=, *=, /=,\%=, **=).
			\item Operações entre diferentes tipo irão resultar no tipo mais complexo
			\item Cuidado, números inteiros tem precisão infinita
			\item Controle de fluxo e bool
		\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Estruturas Básicas do python}
\begin{itemize}
	\item Iteráveis:
	\begin{table}[]
		\centering
		\caption{Iteráveis}
		\label{my-label}
		\begin{tabular}{|l|c|c|l|l|}
			\hline
			\multicolumn{1}{|c|}{} & Ordenada              & Modificável           & \multicolumn{1}{c|}{Unicidade}  \\ \hline
			strings                   & \multicolumn{0}{c|}{X} &                           &                       \\ \hline
			listas                 & X                     & X                     &                                          \\ \hline
			tuplas                 & X                     & \multicolumn{1}{l|}{} &                    \\ \hline
			sets                   & \multicolumn{1}{l|}{} & X                     & \multicolumn{1}{c|}{X}                             \\ \hline
		\end{tabular}
	\end{table}
	\item Vamos tentar um pouco de código
\end{itemize}
		\textbf{\text{Obs: Iremos focar apenas em listas}}
\end{frame}

\begin{frame}{Hackeando Listas com Python}
	\centering \text{Cópia Rasa de listas}
	\lstset{language=Python}
	\lstinputlisting{code/referencia_objeto_lista.py}
	\textbf{\text{Como resolver isso de uma maneira mais fácil?}}
\end{frame}

\begin{frame}{Hackeando Listas com Python}
\begin{itemize}
	\item 	Podemos usar fatiamento de iteráveis (slicing)
	\item 	O fatiamento faz uma cópia de valor do iterável
	\item 	Essa cópia é feita no primeiro nível
	\item 	Para casos específicos pode-se usar deepcopy from copy
	\item \textbf{\text{Python aceita níveis arbitrários em estruturas modificáveis}}
	\item Vamos entender isso no quadro!!!
\end{itemize}
\end{frame}

\begin{frame}{Notas de sintaxe}
	\centering \text{Atenção para a sintaxe}
	\lstset{language=Python}
	\lstinputlisting{code/notas_sintaxe.py}
\end{frame}

\begin{frame}{Notas de sintaxe}
\centering \text{Atenção para a sintaxe}
\lstset{language=Python}
\lstinputlisting{code/notas_sintaxe_2.py}
\end{frame}

\begin{frame}{Hackeando Listas com Python}
	\begin{itemize}
		\item 	O slicing muda a forma como percorremos uma lista
		\item 	Mas e se precisarmos fazer verificações para filtrar a lista?
	\end{itemize}
\end{frame}


\begin{frame}{Hackeando Listas com Python}
	\centering \text{Obtendo Números pares de uma lista}
	\lstset{language=Python}
	\lstinputlisting{code/numeros_pares_errado.py}
\end{frame}

\begin{frame}{Hackeando Listas com Python}
	\centering \text{Fazendo o mesmo de uma forma mais pythônica}
	\lstset{language=Python}
	\lstinputlisting{code/numeros_pares_certo.py}
\end{frame}

\begin{frame}{Dicionários}
\begin{itemize}
	\item São indexados por chaves
	\item Apenas tipos imutáveis podem ser usados como chaves
	\item São criados com um simples par de chaves -> \{\}
\end{itemize}
\end{frame}

\begin{frame}{Dicionários}
\centering \text{Dicionários na prática}
\lstset{language=Python}
\lstinputlisting{code/dicts.py}
\end{frame}

\begin{frame}{Dicionários}
\centering \text{Dicionários na prática}
\lstset{language=Python}
\lstinputlisting{code/dicts2.py}
\end{frame}